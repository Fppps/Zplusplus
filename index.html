<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z++ Language Editor (VS Code Layout)</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for Inter */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1E1E1E; /* VS Code dark background */
            color: #D4D4D4; /* VS Code default text color */
            min-height: 100vh; /* Ensure body takes full viewport height */
            display: flex;
            flex-direction: column;
        }
        .app-container { /* Main wrapper for the entire page content */
            max-width: 1000px; /* Wider container for editor layout */
            margin: 2rem auto;
            padding: 1.5rem;
            background-color: #252526; /* VS Code panel/sidebar background */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex; /* Use flexbox for overall layout */
            flex-direction: column;
            gap: 1.5rem; /* Spacing between sections */
            flex-grow: 1; /* Allow container to grow */
        }

        /* Styles for the "Concepts Explained" section */
        .concepts-section-content { /* Renamed to indicate it's the content pane */
            padding: 1.5rem;
            background-color: #2D2D2D; /* Slightly different background for this section */
            border-radius: 0.5rem;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
        }
        .concepts-section-content .inner-card {
            background-color: #3C3C3C; /* Even lighter background for individual cards */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        /* Tab specific styles */
        .tab-bar {
            display: flex;
            background-color: #2D2D2D; /* Tab bar background */
            border-radius: 0.25rem 0.25rem 0 0; /* Rounded top corners */
            overflow: hidden; /* Ensure rounded corners clip */
        }
        .tab-button {
            padding: 0.75rem 1.25rem;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            color: #858585; /* Inactive tab text */
            background-color: #2D2D2D; /* Inactive tab background */
            border-right: 1px solid #3C3C3C; /* Separator between tabs */
            transition: all 0.2s ease-in-out;
        }
        .tab-button:last-child {
            border-right: none;
        }
        .tab-button.active {
            background-color: #1E1E1E; /* Active tab background (editor background) */
            color: #D4D4D4; /* Active tab text */
            border-bottom: 2px solid #569CD6; /* Active tab indicator blue */
            position: relative;
            z-index: 1; /* Bring active tab to front */
            margin-bottom: -1px; /* Overlap with content border */
        }
        .tab-button:hover:not(.active) {
            background-color: #2A2A2A; /* Hover for inactive tabs */
        }

        .tab-content {
            border: 1px solid #3C3C3C;
            border-top: none; /* No top border, as it's covered by active tab */
            border-radius: 0 0 0.25rem 0.25rem; /* Rounded bottom corners */
            flex-grow: 1; /* Content takes remaining space */
            background-color: #1E1E1E; /* Default content background */
            padding: 1rem; /* Default padding for content areas */
            overflow-y: auto; /* Allow scrolling within content if needed */
        }
        .tab-content.hidden {
            display: none;
        }


        /* VS Code-like Editor Window styles - Adjusted for new tab layout */
        .vscode-editor-window {
            display: flex;
            flex-direction: column;
            /* Removed border, background, and border-radius here as it's now applied to tab-content */
            min-height: 500px; /* Minimum height for the editor window (including terminal) */
            flex-grow: 1;
        }

        .top-bar { /* Now serves as header for the tabbed content area */
            display: none; /* Hide the old top-bar as we have tab-bar now */
        }

        .file-tab {
            display: none; /* Hide old file-tab */
        }

        .editor-container { /* Holds CodeMirror and buttons */
            flex-grow: 1; /* Editor takes available space */
            display: flex;
            flex-direction: column;
            padding: 1rem; /* Padding inside the editor pane */
            /* Removed padding from here as it's applied to tab-content */
            border: none; /* No border here */
        }

        .toolbar-buttons {
            display: flex;
            justify-content: flex-end; /* Align buttons to the right */
            gap: 1rem;
            padding: 0.5rem 0;
            border-bottom: 1px solid #3C3C3C; /* Separator above terminal */
            margin-bottom: 1rem;
        }
        .toolbar-buttons button {
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            border-radius: 0.25rem;
        }

        .terminal-pane {
            background-color: #1E1E1E; /* Terminal background */
            border-top: 1px solid #3C3C3C; /* Separator from editor */
            min-height: 150px; /* Minimum height for terminal */
            max-height: 300px; /* Max height for terminal */
            overflow-y: auto; /* Scrollable terminal */
            display: flex;
            flex-direction: column;
            flex-shrink: 0; /* Prevents terminal from shrinking too much */
        }

        .terminal-header {
            background-color: #2D2D2D; /* Terminal tab bar background */
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #3C3C3C;
            font-size: 0.9rem;
            font-weight: 600;
            color: #D4D4D4;
            cursor: default;
        }

        .output-area {
            flex-grow: 1;
            background-color: #1E1E1E; /* Editor background */
            color: #D4D4D4;
            padding: 0.75rem;
            border-radius: 0; /* Remove border-radius here, applied to parent */
            min-height: 0; /* Allow flex-grow to control height */
            box-shadow: none; /* Remove box-shadow here */
            font-size: 0.85rem; /* Smaller font for terminal */
        }
        
        /* CodeMirror styles - Adjusted for VS Code like appearance */
        .CodeMirror {
            border: 1px solid #3C3C3C; /* VS Code border color */
            border-radius: 0.25rem; /* Slight rounded corners */
            font-size: 0.875rem; /* text-sm */
            height: 12rem; /* Fixed height for the editor */
            line-height: 1.5; /* Better line spacing */
            flex-grow: 1; /* Allow CodeMirror to take available space */
        }
        .CodeMirror-scroll {
            background-color: #1E1E1E; /* VS Code editor background */
            color: #D4D4D4; /* Default text color */
        }
        .CodeMirror-gutters {
            background-color: #2D2D2D; /* VS Code gutter background */
            border-right: 1px solid #3C3C3C;
        }
        .CodeMirror-linenumbers {
            color: #858585; /* VS Code line number color */
        }

        /* Active line background */
        .CodeMirror-activeline-background {
            background: #2A2A2A; /* Slightly lighter than editor background for active line */
        }

        /* Cursor color */
        .CodeMirror-cursor {
            border-left: 1px solid #D4D4D4; /* White cursor */
        }

        /* Z++ Syntax Highlighting - These will be largely overridden by the theme but kept for custom elements */
        .cm-keyword { color: #569CD6; } /* VS Code Blue for keywords */
        .cm-operator { color: #D4D4D4; } /* White for operators */
        .cm-number { color: #B5CEA8; } /* Light green for numbers */
        .cm-string { color: #CE9178; } /* Orange-brown for strings */
        .cm-variable-2 { color: #9CDCFE; } /* Light blue for -variable- names */
        .cm-builtin { color: #4EC9B0; } /* Teal for built-in functions */
        .cm-comment { color: #6A9955; font-style: italic; } /* Green for comments */
        .cm-punctuation { color: #D4D4D4; } /* White for semicolons etc. */
        .cm-bracket { color: #D4D4D4; } /* White for brackets etc. */
        .cm-error { color: #F44747; } /* Red for errors */
        .cm-variable-3 { color: #D7BA7D; } /* Yellow for Module.FuncName */

        /* Override Dracula defaults where needed or for custom tokens */
        .cm-s-dracula .cm-keyword { color: #FF79C6; } /* Dracula pink for keywords */
        .cm-s-dracula .cm-operator { color: #FFB86C; } /* Dracula orange for operators */
        .cm-s-dracula .cm-string { color: #F1FA8C; } /* Dracula yellow for strings */
        .cm-s-dracula .cm-number { color: #BD93F9; } /* Dracula purple for numbers */
        .cm-s-dracula .cm-variable-2 { color: #50FA7B; } /* Dracula green for -variables- */
        .cm-s-dracula .cm-builtin { color: #8BE9FD; } /* Dracula cyan for built-ins */
        .cm-s-dracula .cm-comment { color: #6272A4; } /* Dracula gray for comments */
        .cm-s-dracula .cm-variable-3 { color: #FFB86C; } /* Dracula orange for Module.Func */

    </style>
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.1/codemirror.min.css">
    <!-- CodeMirror Dracula Theme CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.1/theme/dracula.min.css">
</head>
<body class="p-4 md:p-8">
    <div class="app-container">
        <h1 class="text-3xl font-bold text-center mb-6 text-indigo-400">Welcome to Z++</h1>
        <p class="mb-6 text-lg text-gray-300">
            This is a conceptual demonstration of the Z++ language, showcasing its unique syntax and features.
            You can enter Z++-like code in the console below and see a simulated output based on the rules we've defined.
        </p>

        <!-- Tab Bar -->
        <div class="tab-bar">
            <div id="concepts-tab-button" class="tab-button active">Z++ Concepts</div>
            <div id="editor-tab-button" class="tab-button">Z++ Editor</div>
        </div>

        <!-- Tab Content Containers -->
        <div id="concepts-tab-content" class="tab-content concepts-section-content">
            <!-- Z++ Concepts Explained Section (moved here) -->
            <h2 class="text-2xl font-semibold text-indigo-300 mb-4">Z++ Concepts Explained</h2>
            <div class="space-y-4 text-gray-300">
                <!-- Define Keyword and Naming -->
                <div class="inner-card">
                    <h3 class="font-bold text-indigo-200">The <code class="bg-gray-800 p-1 rounded">Define</code> Keyword and <code class="bg-gray-800 p-1 rounded">- -</code> Naming</h3>
                    <p>
                        In Z++, <strong class="text-indigo-300">`Define`</strong> is the universal keyword for introducing *all* named entities â€“ variables, constants, or functions. The unique <strong class="text-indigo-300">`- -`</strong> delimiters are used to wrap the name of the entity, like so: <code class="bg-gray-800 p-1 rounded">Define -myVariable- = 123;</code> or <code class="bg-gray-800 p-1 rounded">Define -myFunction-(param) { ... }</code>. The scope of these defined entities depends on where they are declared.
                    </p>
                </div>
                <!-- Define.log for Output -->
                <div class="inner-card">
                    <h3 class="font-bold text-indigo-200">Output with <code class="bg-gray-800 p-1 rounded">Define.log</code></h3>
                    <p>
                        For output, Z++ uses <strong class="text-indigo-300">`Define.log`</strong>. This isn't just a simple print statement; it's conceptualized as defining something for display. It supports custom output levels:
                        <ul class="list-disc list-inside ml-4 mt-2">
                            <li><code class="bg-gray-800 p-1 rounded">Define.log "Hello!";</code> (Default level 1: Normal output)</li>
                            <li><code class="bg-gray-800 p-1 rounded">Define.log (0) "Silent message";</code> (Level 0: No visible output)</li>
                            <li><code class="bg-gray-800 p-1 rounded">Define.log (2) "Error detected!";</code> (Level 2: Normal output with error checking indication)</li>
                        </ul>
                    </p>
                </div>
                <!-- Mini-Functions with =? -->
                <div class="inner-card">
                    <h3 class="font-bold text-indigo-200">Mini-Functions with <code class="bg-gray-800 p-1 rounded"> =? </code></h3>
                    <p>
                        Z++ offers compact 'mini-functions' for inline operations. These are declared using <strong class="text-indigo-300">`MiniFunc`</strong> (or similar) and use the special <strong class="text-indigo-300">` =? `</strong> operator to explicitly define their return value, e.g., <code class="bg-gray-800 p-1 rounded">MiniFunc -square-(x) =? x * x;</code>.
                    </p>
                </div>
                <!-- Conditional Operations with =| -->
                <div class="inner-card">
                    <h3 class="font-bold text-indigo-200">Conditional Operations with <code class="bg-gray-800 p-1 rounded"> =| </code></h3>
                    <p>
                        The <strong class="text-indigo-300">` =| `</strong> operator facilitates conditional assignment and output, with a "stop midway" capability. If the operation on the right-hand side succeeds, the value is assigned and potentially outputted. If a predefined 'stop' condition is met, the assignment and output are skipped, and execution flow can be altered. Example: <code class="bg-gray-800 p-1 rounded">Define -result- =| riskyOperation();</code>
                    </p>
                </div>
                <!-- Extending with ZmPut and 'Zuss' Addons -->
                <div class="inner-card">
                    <h3 class="font-bold text-indigo-200">Extending with <code class="bg-gray-800 p-1 rounded">ZmPut</code> and 'Zuss' Addons</h3>
                    <p>
                        Z++ can be extended with custom 'Zuss' addons using the <strong class="text-indigo-300">`ZmPut`</strong> function (e.g., <code class="bg-gray-800 p-1 rounded">ZmPut "Zuss";</code>). These addons can introduce powerful features, such as the `Prev.log` logging system.
                    </p>
                    <p class="mt-2">
                        <strong class="text-indigo-300">`Prev.log:`</strong> provides an advanced console with 2D output capabilities and error checking. It uses an access parameter (<strong class="text-indigo-300">`'X0'` to `'X10'`</strong>) as its first argument within the data list:
                        <ul class="list-disc list-inside ml-4 mt-2">
                            <li><code class="bg-gray-800 p-1 rounded">Prev.log: (['X0', "--Normal message--"]);</code> (Basic start output)</li>
                            <li><code class="bg-gray-800 p-1 rounded">Prev.log: (['X2', ["--Row 1--", "--Row 2--"]]);</code> (2D output via 'X1'-'X9' if data is structured for it)</li>
                            <li><code class="bg-gray-800 p-1 rounded">Prev.log: (['X10', "Value to check"]);</code> (Output with error checking)</li>
                        </ul>
                    </p>
                    <p class="mt-2">
                        'Zuss' addons can also contain custom modules, imported using <strong class="text-indigo-300">`module =!> -ModuleName- { ... }`</strong>, allowing for modular code organization within the addon.
                    </p>
                </div>
            </div>
        </div>

        <div id="editor-tab-content" class="tab-content vscode-editor-window hidden">
            <!-- Z++ Interactive Editor Section (moved here) -->
            <div class="top-bar">
                <span class="file-tab">main.zpp</span>
            </div>
            <div class="editor-container">
                <label for="zpp-code-editor" class="block text-gray-300 text-lg font-medium mb-2">Enter Z++ Code:</label>
                <div id="zpp-code-editor"></div>
                <div class="toolbar-buttons">
                    <button id="run-code" class="bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500">
                        Run Z++ Code
                    </button>
                    <button id="reset-editor" class="bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500">
                        Reset Editor
                    </button>
                </div>
            </div>
            <div class="terminal-pane">
                <div class="terminal-header">Output:</div>
                <pre id="zpp-output" class="output-area"></pre>
            </div>
        </div>
    </div>

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.1/codemirror.min.js"></script>
    <!-- CodeMirror Simple Mode for custom language definition -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.1/addon/mode/simple.min.js"></script>
    <!-- CodeMirror Dracula Theme JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.1/theme/dracula.min.js"></script>
    <script>
        // === Zuss Addon Class ===
        class Zuss {
            constructor(appendOutputFn, resolveVariableFn, evaluateExpressionFn) {
                this.appendOutput = appendOutputFn;
                this.resolveVariable = resolveVariableFn;
                this.evaluateExpression = evaluateExpressionFn;
            }

            // Implementation of Prev.log:
            log(argsString) {
                let args = [];
                try {
                    // Attempt to parse arguments as a JSON-like array
                    // Replace single quotes and -variable- with double quotes for JSON.parse
                    let jsonString = `[${argsString.replace(/'/g, '"').replace(/--([a-zA-Z0-9_]+)--/g, (match, p1) => {
                        const resolved = this.resolveVariable(p1);
                        return resolved !== undefined ? JSON.stringify(resolved) : match;
                    })}]`;
                    args = JSON.parse(jsonString);
                } catch (e) {
                    this.appendOutput(`Error parsing Prev.log arguments: ${e.message}`, 'error');
                    return;
                }

                let accessParam = args[0];
                let logData = args.slice(1);

                this.appendOutput(`(Access: ${accessParam})`, 'zuss');

                if (accessParam === 'X0') {
                    this.appendOutput(`  Output: ${logData.map(item => typeof item === 'string' ? item.replace(/--/g, '') : item).join(', ')}`, 'zuss');
                } else if (accessParam >= 'X1' && accessParam <= 'X9') { // Corrected: X0 is handled separately, only X1-X9 for 2D
                    this.appendOutput(`  (Simulated 2D Output for ${accessParam})`, 'zuss');
                    if (Array.isArray(logData[0]) && logData[0].every(Array.isArray)) {
                        logData[0].forEach((row, rowIndex) => {
                            this.appendOutput(`  Row ${rowIndex + 1}: [ ${row.map(item => {
                                return typeof item === 'string' ? item.replace(/-([a-zA-Z0-9_]+)-/g, (match, p1) => {
                                    const resolved = this.resolveVariable(p1);
                                    return resolved !== undefined ? resolved : match;
                                }).replace(/--/g, '') : item;
                            }).join(' | ')} ]`, 'zuss');
                        });
                    } else {
                        this.appendOutput(`  (Data provided doesn't look like a 2D array for ${accessParam}: ${JSON.stringify(logData)})`, 'zuss');
                    }
                } else if (accessParam === 'X10') {
                    this.appendOutput(`  Output (with Error Check): ${logData.map(item => typeof item === 'string' ? item.replace(/--/g, '') : item).join(', ')}`, 'zuss');
                } else {
                    this.appendOutput(`  Unknown access parameter for Prev.log: ${accessParam}`, 'error');
                }
            }
        }
        // === End Zuss Addon Class ===


        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired!"); 
            // Define the custom Z++ CodeMirror mode
            CodeMirror.defineSimpleMode("zplusplus", {
                start: [
                    // Keywords
                    {regex: /Define(?=\s)/, token: "keyword"},
                    {regex: /Module(?=\s)/, token: "keyword"},
                    {regex: /Scope(?=\s)/, token: "keyword"},
                    {regex: /Func(?=\s)/, token: "keyword"},
                    {regex: /Defun(?=\s)/, token: "keyword"},
                    {regex: /MiniFunc(?=\s)/, token: "keyword"},
                    {regex: /ZmPut(?=\s)/, token: "keyword"},
                    {regex: /Return(?=\s)/, token: "keyword"},
                    {regex: /module =!>/, token: "keyword"},
                    {regex: /ToString(?=\s*\(|\s*;)/, token: "keyword"}, // ToString function call or declaration

                    // Operators
                    {regex: /=\?/, token: "operator"}, // =?
                    {regex: /=\|/, token: "operator"}, // =|
                    {regex: /=/, token: "operator"}, // regular assignment
                    {regex: /\+\-|-\+|\*|\/|\+\=|\-\=|\*=|%=/, token: "operator"}, // Basic math operators, compound assignments

                    // Numbers
                    {regex: /\b-?\d+(?:\.\d+)?\b/, token: "number"}, // Handles integers and floats

                    // Strings (double or single quoted)
                    {regex: /"(?:[^\\]|\\.)*?"/, token: "string"},
                    {regex: /'(?:[^\\]|\\.)*?'/, token: "string"},

                    // -variable- names (these are a custom 'variable-2' token)
                    {regex: /--([a-zA-Z0-9_]+)--/, token: "variable-2"},

                    // Special functions/addon access
                    {regex: /Define\.log/, token: "builtin"},
                    {regex: /Prev\.log:/, token: "builtin"},
                    // Module.Function (e.g., MyModule.-myFunc-)
                    {regex: /([a-zA-Z0-9_]+)\.--([a-zA-Z0-9_]+)--/, token: "variable-3"},

                    // Comments (single line)
                    {regex: /\/\/.*$/, token: "comment"},
                    // Basic block comments (non-nesting for simple mode)
                    {regex: /\/\*/, token: "comment", next: "comment"},

                    // Parentheses, braces, brackets, semicolon
                    {regex: /[\(\)\[\]\{\}]/, token: "bracket"},
                    {regex: /;/, token: "punctuation"},
                ],
                // State for block comments
                comment: [
                    {regex: /.*?\*\//, token: "comment", next: "start"},
                    {regex: /.*/, token: "comment"}
                ],
                // The meta property specifies where to find the styles for the mode
                meta: {
                    dontIndentStates: ["comment"],
                    lineComment: "//"
                }
            });


            // Get references to DOM elements
            const conceptsTabButton = document.getElementById('concepts-tab-button');
            const editorTabButton = document.getElementById('editor-tab-button');
            const conceptsTabContent = document.getElementById('concepts-tab-content');
            const editorTabContent = document.getElementById('editor-tab-content');

            const runCodeButton = document.getElementById('run-code');
            const resetEditorButton = document.getElementById('reset-editor');
            const zppOutputDiv = document.getElementById('zpp-output');
            const zppCodeEditorDiv = document.getElementById('zpp-code-editor');

            const defaultCode = `Define -myVar- = 10;
Define -greeting- = 'Hello Z++!';
Define.log -greeting-;
Define.log (2) 'Checking variable: ' + -myVar-;

ZmPut 'Zuss';
Prev.log: (['X0', 'Zuss is ready!']);
// Example of 2D output (conceptual, actual rendering depends on Zuss implementation)
Prev.log: (['X5', [['--Item 1--', '--Item 2--'], ['--Item 3--', '--Item 4--', -myVar-]]]);

Define -operationResult- =| 'success'; // Try 'fail' to see stop midway
Define.log 'Result of conditional: ' + -operationResult-;

MiniFunc -double-(x) =? x * 2;
Define -doubledVar- = -double-(5);
Define.log 'Doubled value: ' + -doubledVar-;

Define -addNumbers-(a, b) {
    Define -sum- = a + b;
    Return -sum-;
}
Define -resultSum- = -addNumbers-( -myVar-, 20 );
Define.log 'Sum from function: ' + -resultSum-;

Module -MathLib- {
    Define -PI- = 3.14159;
    Define -circumference-(radius) {
        Return 2 * -MathLib.PI- * radius;
    }
}
Define -circleCircumference- = -MathLib.circumference-(5);
Define.log 'Circle circumference: ' + -circleCircumference-;

Define -numberToString- = ToString(123);
Define.log 'Number as string: ' + -numberToString-;

module =!> -MyZussModule- {
    Define -greetUser-(name) {
        Define.log 'Hello from Zuss module, ' + name + '!';
    }
}
Define -MyZussModule.greetUser-('Alice');
`;

            // Initialize CodeMirror editor
            // Initialize CodeMirror only when the editor tab is selected, or ensure it's refreshed.
            let zppEditor = null; // Declare zppEditor here so it's accessible globally within this scope

            const initializeEditor = () => {
                if (!zppEditor) {
                    zppEditor = CodeMirror(zppCodeEditorDiv, {
                        value: defaultCode,
                        mode: "zplusplus",
                        lineNumbers: true,
                        theme: "dracula",
                        indentUnit: 4,
                        tabSize: 4,
                        indentWithTabs: false,
                        smartIndent: true,
                        autoCloseBrackets: true,
                    });
                    console.log("CodeMirror editor initialized."); // Debugging point: Editor initialized
                } else {
                    zppEditor.refresh(); // Refresh if already initialized but hidden
                    console.log("CodeMirror editor refreshed."); // Debugging point: Editor refreshed
                }
            };

            // Z++ Interpreter Environment
            let zppEnvironment = {
                definedScope: {},
                zuss: null,
                callStack: [],
                currentModule: null,

                appendOutput: function(message, type = 'info') {
                    console.log(`[appendOutput called] Message: ${message}, Type: ${type}`);
                    const prefix = {
                        'info': '[Z++ Log] ',
                        'debug': '[Z++ Debug] ',
                        'warn': '[Z++ Warning] ',
                        'error': '[Z++ Error] ',
                        'system': '[Z++ System] ',
                        'zuss': '[Zuss Prev.log] '
                    }[type] || '';
                    const color = {
                        'info': 'text-gray-200',
                        'debug': 'text-green-300',
                        'warn': 'text-yellow-300',
                        'error': 'text-red-500',
                        'system': 'text-blue-300',
                        'zuss': 'text-purple-300'
                    }[type] || 'text-gray-200';

                    zppOutputDiv.innerHTML += `<span class="${color}">${prefix}${message}</span><br>`;
                    zppOutputDiv.scrollTop = zppOutputDiv.scrollHeight;
                },

                resolveVariable: function(varName) {
                    const currentScope = this.callStack.length > 0 ? this.callStack[this.callStack.length - 1].localVars : this.definedScope;
                    
                    if (currentScope[varName] !== undefined) {
                        return currentScope[varName];
                    }
                    if (this.definedScope[varName] !== undefined) {
                        return this.definedScope[varName];
                    }
                    const moduleMatch = varName.match(/^([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)$/);
                    if (moduleMatch && this.definedScope[moduleMatch[1]] && this.definedScope[moduleMatch[1]][moduleMatch[2]] !== undefined) {
                         return this.definedScope[moduleMatch[1]][moduleMatch[2]];
                    }
                    return undefined;
                },

                evaluateExpression: function(expr, scope) {
                    expr = expr.trim();

                    let toStringMatch = expr.match(/^ToString\((.+)\)$/);
                    if (toStringMatch) {
                        let innerExpr = toStringMatch[1];
                        let value = this.evaluateExpression(innerExpr, scope);
                        return String(value);
                    }

                    if ((expr.startsWith('"') && expr.endsWith('"')) || (expr.startsWith("'") && expr.endsWith("'"))) {
                        return expr.slice(1, -1);
                    }
                    if (!isNaN(expr)) {
                        return Number(expr);
                    }
                    if (expr === 'true') return true;
                    if (expr === 'false') return false;

                    let varMatch = expr.match(/^-([a-zA-Z0-9_]+)-$/);
                    if (varMatch) {
                        const varName = varMatch[1];
                        const resolved = this.resolveVariable(varName);
                        if (resolved === undefined) {
                            this.appendOutput(`Undefined variable reference: -${varName}-`, 'error');
                            throw new Error(`Undefined variable: -${varName}-`);
                        }
                        return resolved;
                    }

                    try {
                        let jsExpr = expr.replace(/-([a-zA-Z0-9_]+)-/g, (match, p1) => {
                            const resolved = this.resolveVariable(p1);
                            if (resolved === undefined) {
                                this.appendOutput(`Undefined variable in expression: -${p1}-`, 'error');
                                throw new Error(`Undefined variable: -${p1}-`);
                            }
                            return JSON.stringify(resolved);
                        });
                        // eslint-disable-next-line no-eval
                        return eval(jsExpr);
                    } catch (e) {
                        this.appendOutput(`Error evaluating expression '${expr}': ${e.message}`, 'error');
                        throw e;
                    }
                },

                processLine: function(line, currentScope = this.definedScope) {
                    console.log(`Inside processLine: ${line}`);
                    line = line.split('//')[0].trim();
                    if (line.length === 0) return null;

                    let matchDefineVar = line.match(/^Define -([a-zA-Z0-9_]+)- = (.+);$/);
                    let matchDefineModuleVar = line.match(/^Define -([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)- = (.+);$/);

                    if (matchDefineModuleVar) {
                        let moduleName = matchDefineModuleVar[1];
                        let varName = matchDefineModuleVar[2];
                        let varValueExpr = matchDefineModuleVar[3];

                        if (!this.definedScope[moduleName] || typeof this.definedScope[moduleName] !== 'object') {
                            this.definedScope[moduleName] = {};
                            this.appendOutput(`[Z++ Debug] Created module object: ${moduleName}`, 'debug');
                        }
                        try {
                            const parsedValue = this.evaluateExpression(varValueExpr, currentScope);
                            this.definedScope[moduleName][varName] = parsedValue;
                            this.appendOutput(`[Z++ Debug] Defined module var: ${moduleName}.-${varName}- = ${JSON.stringify(parsedValue)}`, 'debug');
                        } catch (e) {
                             this.appendOutput(`Error defining module variable: ${e.message}`, 'error');
                        }
                        return null;
                    }
                    else if (matchDefineVar) {
                        let varName = matchDefineVar[1];
                        let varValueExpr = matchDefineVar[2];
                        try {
                            const parsedValue = this.evaluateExpression(varValueExpr, currentScope);
                            currentScope[varName] = parsedValue;
                            this.appendOutput(`[Z++ Debug] Defined: -${varName}- = ${JSON.stringify(currentScope[varName])}`, 'debug');
                        } catch (e) {
                            // Error message already appended by evaluateExpression
                        }
                        return null;
                    }

                    let matchDefineLog = line.match(/^Define\.log (\((\d)\))? (.+);$/);
                    if (matchDefineLog) {
                        let level = matchDefineLog[2] ? parseInt(matchDefineLog[2]) : 1;
                        let contentExpr = matchDefineLog[3].trim();
                        
                        try {
                             let content = this.evaluateExpression(contentExpr, currentScope);

                            if (level === 0) {
                                this.appendOutput(`(Output suppressed)`, 'info');
                            } else if (level === 1) {
                                this.appendOutput(`${content}`, 'info');
                            } else if (level === 2) {
                                this.appendOutput(`${content} (Error Check)`, 'warn');
                            } else {
                                this.appendOutput(`Unknown log level ${level}: ${content}`, 'warn');
                            }
                        } catch (e) {
                            // Error already logged by evaluateExpression
                        }
                        return null;
                    }

                    let matchZmPut = line.match(/^ZmPut "Zuss";$/);
                    if (matchZmPut) {
                        this.zuss = new Zuss(this.appendOutput.bind(this), this.resolveVariable.bind(this), this.evaluateExpression.bind(this));
                        this.appendOutput(`Zuss addon loaded.`, 'system');
                        return null;
                    }

                    let matchPrevLog = line.match(/^Prev\.log: \(\[(.+?)\]\);$/);
                    if (matchPrevLog) {
                        if (!this.zuss) {
                            this.appendOutput(`Prev.log: called but Zuss addon not loaded. Use 'ZmPut "Zuss";' first.`, 'error');
                            return null;
                        }
                        this.zuss.log(matchPrevLog[1]);
                        return null;
                    }

                    let matchMiniFunc = line.match(/^MiniFunc -([a-zA-Z0-9_]+)-\((.+?)\) =\? (.+);$/);
                    if (matchMiniFunc) {
                        let funcName = matchMiniFunc[1];
                        let paramName = matchMiniFunc[2];
                        let expression = matchMiniFunc[3];
                        
                        this.definedScope[funcName] = {
                            type: 'MiniFunc',
                            params: [paramName],
                            body: expression,
                            execute: (args, scope) => {
                                const tempScope = { ...scope, [paramName]: args[0] };
                                return this.evaluateExpression(expression, tempScope);
                            }
                        };
                        this.appendOutput(`Registered MiniFunc: -${funcName}-(${paramName}) =? ${expression}`, 'debug');
                        return null;
                    }

                    let matchDefineFunc = line.match(/^Define -([a-zA-Z0-9_]+)-\((.*?)\)\s*\{(.+?)\}/s);
                    if (matchDefineFunc) {
                        let funcName = matchDefineFunc[1];
                        let params = matchDefineFunc[2].split(',').map(p => p.trim()).filter(p => p.length > 0);
                        let body = matchDefineFunc[3].trim();
                        let bodyLines = body.split('\n').map(l => l.trim()).filter(l => l.length > 0);

                        let actualFuncName = funcName;
                        let targetScope = this.definedScope;

                        if (this.currentModule) {
                            if (!targetScope[this.currentModule]) {
                                targetScope[this.currentModule] = {};
                            }
                            targetScope = targetScope[this.currentModule];
                            actualFuncName = funcName;
                        }
                        
                        targetScope[actualFuncName] = {
                            type: 'Function',
                            params: params,
                            body: bodyLines,
                            execute: (args, parentScope) => {
                                let returnVal = undefined;
                                const localScope = { ...parentScope };
                                
                                params.forEach((param, i) => {
                                    localScope[param] = args[i];
                                });

                                this.callStack.push({ localVars: localScope, returnVal: undefined });

                                for (let i = 0; i < bodyLines.length; i++) {
                                    const bodyLine = bodyLines[i];
                                    let result = this.processLine(bodyLine, localScope);
                                    if (result && result.type === 'Return') {
                                        this.callStack[this.callStack.length - 1].returnVal = result.value;
                                        returnVal = result.value;
                                        break;
                                    }
                                }
                                this.callStack.pop();
                                return returnVal;
                            }
                        };
                        this.appendOutput(`Registered Function: -${funcName}-(${params.join(', ')})`, 'debug');
                        return null;
                    }

                    let matchConditionalAssign = line.match(/^Define -([a-zA-Z0-9_]+)- =\| (.+);$/);
                    if (matchConditionalAssign) {
                        let varName = matchConditionalAssign[1];
                        let exprValue = matchConditionalAssign[2].trim();
                        let targetScope = this.callStack.length > 0 ? this.callStack[this.callStack.length - 1].localVars : this.definedScope;

                        if (exprValue === "'fail'" || exprValue === '"fail"' || exprValue === 'null' || exprValue === 'undefined') {
                            this.appendOutput(`Operation for -${varName}- stopped midway.`, 'warn');
                            targetScope[varName] = null;
                        } else {
                            try {
                                let assignedValue = this.evaluateExpression(exprValue, targetScope);
                                targetScope[varName] = assignedValue;
                                this.appendOutput(`Conditional assign: -${varName}- = ${JSON.stringify(assignedValue)}`, 'debug');
                            } catch (e) {
                                targetScope[varName] = null;
                            }
                        }
                        return null;
                    }

                    let matchFuncCall = line.match(/^Define -([a-zA-Z0-9_]+)- = -([a-zA-Z0-9_.]+)-\((.*?)\);$/);
                    if (matchFuncCall) {
                        let resultVarName = matchFuncCall[1];
                        let fullFuncName = matchFuncCall[2];
                        let argsString = matchFuncCall[3];

                        let func = null;
                        let moduleFuncMatch = fullFuncName.match(/^([a-zA-Z0-9_]+)\.([a-zA-Z0-9_]+)$/);
                        if (moduleFuncMatch) {
                            let moduleName = moduleFuncMatch[1];
                            let fName = moduleFuncMatch[2];
                            if (this.definedScope[moduleName] && this.definedScope[moduleName][fName]) {
                                func = this.definedScope[moduleName][fName];
                            }
                        } else {
                            func = this.definedScope[fullFuncName];
                        }
                        
                        if (func && (func.type === 'Function' || func.type === 'MiniFunc')) {
                            let callArgs = argsString.split(',').map(arg => {
                                const trimmedArg = arg.trim();
                                if (trimmedArg.startsWith('--') && trimmedArg.endsWith('--')) {
                                    return this.resolveVariable(trimmedArg.slice(2, -2));
                                }
                                return this.evaluateExpression(trimmedArg, currentScope);
                            });

                            let result = func.execute(callArgs, currentScope);
                            currentScope[resultVarName] = result;
                            this.appendOutput(`Function -${fullFuncName}- called. Result: -${resultVarName}- = ${JSON.stringify(result)}`, 'debug');
                        } else {
                            this.appendOutput(`Undefined function or MiniFunc: -${fullFuncName}-`, 'error');
                        }
                        return null;
                    }

                    let matchReturn = line.match(/^Return (.+);$/);
                    if (matchReturn) {
                        let returnExpr = matchReturn[1];
                        try {
                            const returnValue = this.evaluateExpression(returnExpr, currentScope);
                            return { type: 'Return', value: returnValue };
                        } catch (e) {
                            return { type: 'Error', message: `Return value error: ${e.message}` };
                        }
                    }

                    let matchModuleStart = line.match(/^Module -([a-zA-Z0-9_]+)- \{$/);
                    if (matchModuleStart) {
                        this.currentModule = matchModuleStart[1];
                        this.appendOutput(`Entering Module definition: -${this.currentModule}-`, 'debug');
                        if (!this.definedScope[this.currentModule]) {
                            this.definedScope[this.currentModule] = {};
                        }
                        return null;
                    }
                    let matchModuleEnd = line.match(/^\}$/);
                    if (matchModuleEnd && this.currentModule) {
                        this.appendOutput(`Exiting Module definition: -${this.currentModule}-`, 'debug');
                        this.currentModule = null;
                        return null;
                    }

                    let matchZussModuleImport = line.match(/^module =!> -([a-zA-Z0-9_]+)- \{/);
                    if (matchZussModuleImport) {
                        let moduleName = matchZussModuleImport[1];
                        this.appendOutput(`[Zuss System] Zuss Module defined: -${moduleName}-. Functions within this block are accessible via -${moduleName}.functionName-`, 'system');
                        this.currentModule = moduleName;
                        return null;
                    }


                    this.appendOutput(`Unrecognized Z++ line: ${line}`, 'warn');
                    return null;
                },

                // Main execution function
                executeCode: function(code) {
                    console.log("executeCode called!"); 
                    this.zppOutputDiv.innerHTML = ''; // Clear output
                    this.definedScope = {}; // Reset scope
                    this.zuss = null; // Reset Zuss instance
                    this.callStack = [];
                    this.currentModule = null;

                    const lines = code.split('\n')
                                      .map(line => line.trim());

                    let inMultiLineComment = false;
                    for (let i = 0; i < lines.length; i++) {
                        let line = lines[i];

                        if (line.includes('/*')) {
                            inMultiLineComment = true;
                            if (line.includes('*/') && line.indexOf('/*') < line.indexOf('*/')) {
                                line = line.substring(line.indexOf('*/') + 2).trim();
                                inMultiLineComment = false;
                            } else {
                                continue;
                            }
                        } else if (line.includes('*/') && inMultiLineComment) {
                            inMultiLineComment = false;
                            line = line.substring(line.indexOf('*/') + 2).trim();
                        } else if (inMultiLineComment) {
                            continue;
                        }

                        if (line.length > 0) {
                            console.log(`Processing line: ${line}`);
                            this.processLine(line);
                        }
                    }
                }
            };

            // Set up ZppInterpreter's output div
            zppEnvironment.zppOutputDiv = zppOutputDiv;

            // --- Tab Handling Logic ---
            const switchTab = (tabId) => {
                // Deactivate all tab buttons and hide all tab contents
                conceptsTabButton.classList.remove('active');
                editorTabButton.classList.remove('active');
                conceptsTabContent.classList.add('hidden');
                editorTabContent.classList.add('hidden');

                // Activate the clicked tab and show its content
                if (tabId === 'concepts') {
                    conceptsTabButton.classList.add('active');
                    conceptsTabContent.classList.remove('hidden');
                } else if (tabId === 'editor') {
                    editorTabButton.classList.add('active');
                    editorTabContent.classList.remove('hidden');
                    initializeEditor(); // Initialize/refresh CodeMirror when editor tab is shown
                }
            };

            // Event Listeners for Tab Buttons
            conceptsTabButton.addEventListener('click', () => switchTab('concepts'));
            editorTabButton.addEventListener('click', () => switchTab('editor'));

            // Initial tab display: Show concepts tab by default
            // switchTab('concepts'); // Keep concepts visible by default

            // If the user wants the editor tab to be active by default:
            switchTab('editor'); // Show editor tab by default on load

            // Event listeners for the "Run Z++ Code" and "Reset Editor" buttons
            runCodeButton.addEventListener('click', () => {
                console.log("Run button clicked!");
                zppEnvironment.executeCode(zppEditor.getValue());
            });

            resetEditorButton.addEventListener('click', () => {
                zppEditor.setValue(defaultCode);
                zppEnvironment.executeCode('');
                zppOutputDiv.innerHTML = ''; // Ensure output is completely clear
                console.log("Editor reset.");
            });
        });
    </script>
</body>
</html>
